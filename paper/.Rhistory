)
#| echo: false
#| warning: false
#### Preamble ####
# Purpose: Generates a paper titled "Uneven Progress: A Study of Affordable
#Housing Distribution and Development in Torontoâ€™s Wards in PDF format when
# rendered.
# Author: Claire Ma
# Date: September 27, 2024
# Contact: minglu.ma@mail.utoronto.ca
# Pre-requisites: Run the files "01-download_data.R" and "02-data_cleaning.R".
#| echo: false
#| include: false
#| message: false
#| warning: false
#### Loading Packages ####
library(opendatatoronto)
library(tidyverse)
library(knitr)
#| echo: false
#| warning: false
#| message: false
#| label: tbl-cleaneddata
cleaned_data <- read.csv("/Users/luuu/Downloads/starter_folder-main/output/data/cleaned_data.csv")
#| include: false
#| warning: false
#| message: false
library(opendatatoronto)
library(tidyverse)
library(readr)
library(dplyr)
library(tidyr)
library(stats)
library(ggplot2)
library(glmnet)
library(caret)
library(stats)
library(modelsummary)
data <- read.csv("../data/02-analysis_data/cleaned_data.csv")
#| label: tbl-overview
#| echo: false
#| warning: false
#| message: false
#| tbl-cap: "Sample of Cleaned Data"
library(gt)
# Create a GT table with the first 10 rows
data %>%
head(10) %>%
gt() %>%
tab_header(
title = "Overview of Cleaned Data",
subtitle = "Displaying the first 10 rows"
)
#| label: fig-subsidy
#| tbl-cap: "Subsidy Allocation Distribution"
#| echo: false
#| message: false
#| warning: false
# Calculate percentages
data_summary <- data %>%
group_by(subsidy) %>%
summarise(count = n()) %>%
mutate(percentage = round(100 * count / sum(count), 1))  # Calculate percentage
# Create the bar plot with percentage labels
plot1 <- ggplot(data_summary, aes(x = as.factor(subsidy), y = count)) +
geom_bar(stat = "identity", fill = c("skyblue", "coral"), alpha = 0.8) +
geom_text(aes(label = paste0(percentage, "%")), vjust = -0.5, size = 3) +  # Add percentage labels
labs(
title = "Distribution of Subsidy",
x = "Subsidy (0 = No, 1 = Yes)",
y = "Count"
) +
theme_minimal() +
theme(
plot.title = element_text(size = 9),  # Reduce title size
axis.title = element_text(size = 10),  # Reduce axis title size
axis.text = element_text(size = 8)    # Reduce axis text size
)
plot1
#| label: fig-relation_bldgtype
#| tbl-cap: "Proportional Distribution of Subsidy Status Across Building Types"
#| echo: false
#| message: false
#| warning: false
ggplot(data, aes(x = bldg_type, fill = as.factor(subsidy))) +
geom_bar(position = "fill", alpha = 0.8) +
scale_fill_manual(values = c("blue", "red")) +
labs(
x = "Building Type",
y = "Proportion",
fill = "Subsidy Status"
) +
theme_minimal() +
theme(
axis.text.x = element_text(angle = 90, hjust = 1),  # Rotate x-axis labels for readability
plot.title = element_text(size = 12),
axis.title = element_text(size = 10),
axis.text = element_text(size = 9)
)
#| label: fig-relation_Auspice
#| tbl-cap: "Proportional Distribution of Subsidy Status by Auspice"
#| echo: false
#| message: false
#| warning: false
ggplot(data, aes(x = AUSPICE, fill = as.factor(subsidy))) +
geom_bar(position = "fill", alpha = 0.8) +
scale_fill_manual(values = c("blue", "red")) +
labs(
x = "Auspice",
y = "Proportion",
fill = "Subsidy Status"
) +
theme_minimal() +
theme(
axis.text.x = element_text(angle = 45, hjust = 1),  # Rotate x-axis labels for readability
plot.title = element_text(size = 12),
axis.title = element_text(size = 10),
axis.text = element_text(size = 9)
)
#| label: fig-cor_key
#| tbl-cap: "Correlation Heatmap of Key Variables: TOTSPACE, Subsidy, and CWELCC Flag"
#| echo: false
#| message: false
#| warning: false
library(ggcorrplot)
cor_matrix <- cor(data %>% select(TOTSPACE, subsidy, cwelcc_flag), use = "complete.obs")
ggcorrplot(cor_matrix, lab = TRUE)
library(caret)
library(ggplot2)
# Encode categorical variables
data$AUSPICE <- as.factor(data$AUSPICE)
data$bldg_type <- as.factor(data$bldg_type)
# Split the data into training and testing sets
set.seed(1008047418)
train_index <- createDataPartition(data$subsidy, p = 0.7, list = FALSE)
train_data <- data[train_index, ]
test_data <- data[-train_index, ]
# Fit logistic regression model
log_model <- glm(subsidy ~ ., data = train_data, family = binomial)
# Summary of the model
summary(log_model)
# Stepwise selection based on AIC
step_model_aic <- step(log_model, direction = "both", trace = TRUE)
# Summary of models
summary(step_model_aic)  # AIC-based selected model
# Create a binary variable for "Non Profit Agency"
train_data$AUSPICE_NonProfit <- ifelse(train_data$AUSPICE == "Non Profit Agency", 1, 0)
# Refit the model with the binary variable for AUSPICE
reduced_model_re2 <- glm(formula = subsidy ~ AUSPICE_NonProfit + bldg_type + cwelcc_flag + TOTSPACE,
family = binomial, data = train_data)
# Summary of the updated model
summary(reduced_model_re2)
# Refit the best aic model
reduced_model_re <- glm(formula = subsidy ~ AUSPICE + bldg_type + cwelcc_flag + TOTSPACE,
family = binomial, data = train_data)
summary(reduced_model_re)
# Refit model by removing non-significant variables
reduced_model_2 <- glm(formula = subsidy ~ AUSPICE + cwelcc_flag + TOTSPACE,
family = binomial, data = train_data)
summary(reduced_model_2)
#| label: fig-cr
#| tbl-cap: "CR Plot for Linearity Chekck"
#| echo: false
#| message: false
#| warning: false
library(car)
crPlots(reduced_model_2)  # Generate Component + Residual plots
#| label: tbl-vif
#| echo: false
#| warning: false
#| message: false
#| tbl-cap: "VIF values for predictor variables."
library(car)
library(knitr)
library(kableExtra)
# Calculate VIF
vif_values <- vif(reduced_model_2)
# Convert VIF to a data frame for easier manipulation
vif_table <- as.data.frame(vif_values)
vif_table$Variable <- rownames(vif_table)
rownames(vif_table) <- NULL
# Rename columns for clarity
colnames(vif_table) <- c("GVIF", "Df", "GVIF^(1/(2*Df))", "Variable")
# Rearrange columns to make Variable the first column
vif_table <- vif_table[, c("Variable", "GVIF", "Df", "GVIF^(1/(2*Df))")]
# Display VIF table
vif_table %>%
kable(format = "markdown", align = "lccc", booktabs = TRUE, linesep = "") %>%
kable_styling(latex_options = c("hold_position"), full_width = FALSE) %>%
column_spec(2:4, bold = TRUE)
#| label: tbl-coefresult
#| echo: false
#| warning: false
#| message: false
#| tbl-cap: "Regression Result"
# Regression table with standard errors and p-values
model_list <- list(
"Final Model" = reduced_model_2
)
modelsummary(
model_list,
output = "markdown",
statistic = c("std.error", "p.value")
)
library(ggplot2)
library(broom)  # To tidy the model output
# Extract coefficients and confidence intervals
tidy_model <- broom::tidy(reduced_model_2, conf.int = TRUE)
# Highlight significant coefficients
tidy_model <- tidy_model %>%
mutate(significant = ifelse(conf.low > 0 | conf.high < 0, "Significant", "Not Significant"))
# Plot with enhancements
ggplot(tidy_model, aes(x = estimate, y = reorder(term, abs(estimate)), color = significant)) +
geom_point() +
geom_errorbarh(aes(xmin = conf.low, xmax = conf.high), height = 0.2) +
scale_color_manual(values = c("Significant" = "red", "Not Significant" = "black")) +
labs(
title = "Coefficient Plot",
x = "Coefficient Estimate",
y = "Predictor Variables",
color = "Significance"
) +
theme_minimal()
# Calculate log-likelihood of the fitted model
log_likelihood_fitted <- logLik(reduced_model_2)
# Fit the null model (model with intercept only)
null_model <- glm(subsidy ~ 1, data = train_data, family = binomial)
log_likelihood_null <- logLik(null_model)
# McFadden's R-squared
mcfadden_r2 <- 1 - as.numeric(log_likelihood_fitted / log_likelihood_null)
# Print the result
print(paste("McFadden's R-squared:", round(mcfadden_r2, 6)))
#| label: fig-roc
#| tbl-cap: "ROC Curve for Model Performance"
#| echo: false
#| message: false
#| warning: false
library(pROC)
# ROC Curve and AUC
roc_curve <- roc(test_data$subsidy, predict(reduced_model_2, newdata = test_data, type = "response"))
plot(roc_curve, main = "ROC Curve")
auc(roc_curve)
# Generate predicted probabilities for the test dataset
test_data$predicted_prob <- predict(reduced_model_2, newdata = test_data, type = "response")
# Predicted vs. Observed Scatterplot
ggplot(test_data, aes(x = predicted_prob, y = subsidy)) +
geom_jitter(width = 0.02, height = 0.02, alpha = 0.6, color = "blue") +
geom_smooth(method = "loess", color = "red", se = FALSE) +
labs(
title = "Predicted vs. Observed Probability",
x = "Predicted Probability",
y = "Observed Outcome"
) +
theme_minimal()
# Load the modelsummary package
library(modelsummary)
# Create a coefficient table
model_list <- list(
"Full Model" = log_model,
"AIC Model" = reduced_model_re,
"Simplified Model" = reduced_model_2
)
# Customize the table to display only AIC and Deviance
modelsummary(
model_list,
output = "markdown",
gof_map = c("AIC", "Deviance")  # Include only AIC and Deviance in the table
)
#| include: false
#| warning: false
#| message: false
library(opendatatoronto)
library(tidyverse)
library(readr)
library(dplyr)
library(tidyr)
library(stats)
library(ggplot2)
library(glmnet)
library(caret)
library(stats)
library(modelsummary)
data <- read.csv("../data/02-analysis_data/cleaned_data.csv")
#| label: tbl-overview
#| echo: false
#| warning: false
#| message: false
#| tbl-cap: "Sample of Cleaned Data"
library(gt)
# Create a GT table with the first 10 rows
data %>%
head(10) %>%
gt() %>%
tab_header(
title = "Overview of Cleaned Data",
subtitle = "Displaying the first 10 rows"
)
#| label: fig-subsidy
#| fig-cap: "Subsidy Allocation Distribution"
#| echo: false
#| message: false
#| warning: false
# Calculate percentages
data_summary <- data %>%
group_by(subsidy) %>%
summarise(count = n()) %>%
mutate(percentage = round(100 * count / sum(count), 1))  # Calculate percentage
# Create the bar plot with percentage labels
plot1 <- ggplot(data_summary, aes(x = as.factor(subsidy), y = count)) +
geom_bar(stat = "identity", fill = c("skyblue", "coral"), alpha = 0.8) +
geom_text(aes(label = paste0(percentage, "%")), vjust = -0.5, size = 3) +  # Add percentage labels
labs(
title = "Distribution of Subsidy",
x = "Subsidy (0 = No, 1 = Yes)",
y = "Count"
) +
theme_minimal() +
theme(
plot.title = element_text(size = 9),  # Reduce title size
axis.title = element_text(size = 10),  # Reduce axis title size
axis.text = element_text(size = 8)    # Reduce axis text size
)
plot1
#| label: fig-relation_bldgtype
#| fig-cap: "Proportional Distribution of Subsidy Status Across Building Types"
#| echo: false
#| message: false
#| warning: false
ggplot(data, aes(x = bldg_type, fill = as.factor(subsidy))) +
geom_bar(position = "fill", alpha = 0.8) +
scale_fill_manual(values = c("blue", "red")) +
labs(
x = "Building Type",
y = "Proportion",
fill = "Subsidy Status"
) +
theme_minimal() +
theme(
axis.text.x = element_text(angle = 90, hjust = 1),  # Rotate x-axis labels for readability
plot.title = element_text(size = 12),
axis.title = element_text(size = 10),
axis.text = element_text(size = 9)
)
#| label: fig-relation_Auspice
#| fig-cap: "Proportional Distribution of Subsidy Status by Auspice"
#| echo: false
#| message: false
#| warning: false
ggplot(data, aes(x = AUSPICE, fill = as.factor(subsidy))) +
geom_bar(position = "fill", alpha = 0.8) +
scale_fill_manual(values = c("blue", "red")) +
labs(
x = "Auspice",
y = "Proportion",
fill = "Subsidy Status"
) +
theme_minimal() +
theme(
axis.text.x = element_text(angle = 45, hjust = 1),  # Rotate x-axis labels for readability
plot.title = element_text(size = 12),
axis.title = element_text(size = 10),
axis.text = element_text(size = 9)
)
#| label: fig-cor_key
#| fig-cap: "Correlation Heatmap of Key Variables: TOTSPACE, Subsidy, and CWELCC Flag"
#| echo: false
#| message: false
#| warning: false
library(ggcorrplot)
cor_matrix <- cor(data %>% select(TOTSPACE, subsidy, cwelcc_flag), use = "complete.obs")
ggcorrplot(cor_matrix, lab = TRUE)
library(caret)
library(ggplot2)
# Encode categorical variables
data$AUSPICE <- as.factor(data$AUSPICE)
data$bldg_type <- as.factor(data$bldg_type)
# Split the data into training and testing sets
set.seed(1008047418)
train_index <- createDataPartition(data$subsidy, p = 0.7, list = FALSE)
train_data <- data[train_index, ]
test_data <- data[-train_index, ]
# Fit logistic regression model
log_model <- glm(subsidy ~ ., data = train_data, family = binomial)
# Summary of the model
summary(log_model)
# Stepwise selection based on AIC
step_model_aic <- step(log_model, direction = "both", trace = TRUE)
# Summary of models
summary(step_model_aic)  # AIC-based selected model
# Create a binary variable for "Non Profit Agency"
train_data$AUSPICE_NonProfit <- ifelse(train_data$AUSPICE == "Non Profit Agency", 1, 0)
# Refit the model with the binary variable for AUSPICE
reduced_model_re2 <- glm(formula = subsidy ~ AUSPICE_NonProfit + bldg_type + cwelcc_flag + TOTSPACE,
family = binomial, data = train_data)
# Summary of the updated model
summary(reduced_model_re2)
# Refit the best aic model
reduced_model_re <- glm(formula = subsidy ~ AUSPICE + bldg_type + cwelcc_flag + TOTSPACE,
family = binomial, data = train_data)
summary(reduced_model_re)
# Refit model by removing non-significant variables
reduced_model_2 <- glm(formula = subsidy ~ AUSPICE + cwelcc_flag + TOTSPACE,
family = binomial, data = train_data)
summary(reduced_model_2)
#| label: fig-cr
#| fig-cap: "CR Plot for Linearity Chekck"
#| echo: false
#| message: false
#| warning: false
library(car)
crPlots(reduced_model_2)  # Generate Component + Residual plots
#| label: tbl-vif
#| echo: false
#| warning: false
#| message: false
#| tbl-cap: "VIF values for predictor variables."
library(car)
library(knitr)
library(kableExtra)
# Calculate VIF
vif_values <- vif(reduced_model_2)
# Convert VIF to a data frame for easier manipulation
vif_table <- as.data.frame(vif_values)
vif_table$Variable <- rownames(vif_table)
rownames(vif_table) <- NULL
# Rename columns for clarity
colnames(vif_table) <- c("GVIF", "Df", "GVIF^(1/(2*Df))", "Variable")
# Rearrange columns to make Variable the first column
vif_table <- vif_table[, c("Variable", "GVIF", "Df", "GVIF^(1/(2*Df))")]
# Display VIF table
vif_table %>%
kable(format = "markdown", align = "lccc", booktabs = TRUE, linesep = "") %>%
kable_styling(latex_options = c("hold_position"), full_width = FALSE) %>%
column_spec(2:4, bold = TRUE)
#| label: tbl-coefresult
#| echo: false
#| warning: false
#| message: false
#| tbl-cap: "Regression Result"
# Regression table with standard errors and p-values
model_list <- list(
"Final Model" = reduced_model_2
)
modelsummary(
model_list,
output = "markdown",
statistic = c("std.error", "p.value")
)
library(ggplot2)
library(broom)  # To tidy the model output
# Extract coefficients and confidence intervals
tidy_model <- broom::tidy(reduced_model_2, conf.int = TRUE)
# Highlight significant coefficients
tidy_model <- tidy_model %>%
mutate(significant = ifelse(conf.low > 0 | conf.high < 0, "Significant", "Not Significant"))
# Plot with enhancements
ggplot(tidy_model, aes(x = estimate, y = reorder(term, abs(estimate)), color = significant)) +
geom_point() +
geom_errorbarh(aes(xmin = conf.low, xmax = conf.high), height = 0.2) +
scale_color_manual(values = c("Significant" = "red", "Not Significant" = "black")) +
labs(
title = "Coefficient Plot",
x = "Coefficient Estimate",
y = "Predictor Variables",
color = "Significance"
) +
theme_minimal()
# Calculate log-likelihood of the fitted model
log_likelihood_fitted <- logLik(reduced_model_2)
# Fit the null model (model with intercept only)
null_model <- glm(subsidy ~ 1, data = train_data, family = binomial)
log_likelihood_null <- logLik(null_model)
# McFadden's R-squared
mcfadden_r2 <- 1 - as.numeric(log_likelihood_fitted / log_likelihood_null)
# Print the result
print(paste("McFadden's R-squared:", round(mcfadden_r2, 6)))
#| label: fig-roc
#| fig-cap: "ROC Curve for Model Performance"
#| echo: false
#| message: false
#| warning: false
library(pROC)
# ROC Curve and AUC
roc_curve <- roc(test_data$subsidy, predict(reduced_model_2, newdata = test_data, type = "response"))
plot(roc_curve, main = "ROC Curve")
auc(roc_curve)
# Generate predicted probabilities for the test dataset
test_data$predicted_prob <- predict(reduced_model_2, newdata = test_data, type = "response")
# Predicted vs. Observed Scatterplot
ggplot(test_data, aes(x = predicted_prob, y = subsidy)) +
geom_jitter(width = 0.02, height = 0.02, alpha = 0.6, color = "blue") +
geom_smooth(method = "loess", color = "red", se = FALSE) +
labs(
title = "Predicted vs. Observed Probability",
x = "Predicted Probability",
y = "Observed Outcome"
) +
theme_minimal()
# Load the modelsummary package
library(modelsummary)
# Create a coefficient table
model_list <- list(
"Full Model" = log_model,
"AIC Model" = reduced_model_re,
"Simplified Model" = reduced_model_2
)
# Customize the table to display only AIC and Deviance
modelsummary(
model_list,
output = "markdown",
gof_map = c("AIC", "Deviance")  # Include only AIC and Deviance in the table
)
